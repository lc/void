// Package pf projects the in-memory rule set managed by
// the rules package onto BSD pf(4). It owns *all* side-effects:
//   - /etc/pf.anchors/void      — rule blocks generated by Void
//   - /etc/pf.conf              — anchor‐loader stanza (one copy)
//   - pfctl -E -f /etc/pf.conf -F states   — reload when files change
//
// Design guidelines:
//   - Separation of concerns: no business logic lives here.
//   - Atomic, crash-safe writes via filesys.AtomicWrite.
//   - Mutex is held only across rename+pfctl, never while scanning.
//   - Small, exported interface; concrete type unexported.
//   - Unexported globals are prefixed with an underscore to avoid stutter.
package pf

import (
	"bufio"
	"bytes"
	"context"
	"errors"
	"fmt"
	"io"
	"io/fs"
	"net"
	"os/exec"
	"path/filepath"
	"strings"
	"sync"
	"time"

	"github.com/lc/void/internal/filesys"
	"github.com/lc/void/internal/rules"
)

const (
	_pfAnchorPath = "/etc/pf.anchors/void"
	_pfConfPath   = "/etc/pf.conf"
	_pfCtlPath    = "/sbin/pfctl"
)

// Manager projects a slice of rules onto pf files and reloads pf when needed.
// Callers *never* modify files or invoke pfctl directly.
type Manager interface {
	CurrentRules() ([]rules.Rule, error)
	Sync(ctx context.Context, want []rules.Rule) error
}

// manager is the concrete implementation of the Manager interface.
type ManagerImpl struct {
	mu  sync.Mutex // protects write/rename + pfctl
	fs  filesys.FileOps
	cmd runner
}

// New creates a new pf manager.
func New() Manager {
	return &ManagerImpl{
		fs:  filesys.OS(),
		cmd: execRunner{},
	}
}

// CurrentRules parses /etc/pf.anchors/void and returns the rules it finds.
func (m *ManagerImpl) CurrentRules() ([]rules.Rule, error) {
	data, err := m.fs.ReadFile(_pfAnchorPath)
	if err != nil {
		return nil, err // ENOENT: first run, caller ignores
	}
	metas, err := m.walk(bytes.NewReader(data))
	if err != nil {
		return nil, err
	}

	out := make([]rules.Rule, 0, len(metas))
	for _, bm := range metas {
		block := data[bm.start:bm.end]
		r, err := parseBlock(block)
		if err != nil {
			continue
		} // malformed block => skip
		out = append(out, r)
	}
	return out, nil
}

// Sync synchronizes the desired rules with the pf configuration.
func (m *ManagerImpl) Sync(ctx context.Context, want []rules.Rule) error {
	hdrChanged, err := m.ensureAnchor()
	if err != nil {
		return err
	}
	confChanged, err := m.ensurePfConf()
	if err != nil {
		return err
	}
	rulesChanged, err := m.reconcileRules(want)
	if err != nil {
		return err
	}
	if !hdrChanged && !confChanged && !rulesChanged {
		return nil // nothing to do
	}

	if err := m.reload(ctx); err != nil {
		return fmt.Errorf("failed to reload pf: %w", err)
	}
	return nil
}

// reload reloads the pf configuration.
func (m *ManagerImpl) reload(ctx context.Context) error {
	m.mu.Lock()
	defer m.mu.Unlock()

	args := []string{"-E", "-f", _pfConfPath, "-F", "states"}
	err := m.cmd.Run(ctx, _pfCtlPath, args...)
	if err != nil {
		return fmt.Errorf("failed to reload pf: %w", err)
	}
	return err
}

// reconcileRules reconciles the rules in the anchor file with the desired rules.
func (m *ManagerImpl) reconcileRules(want []rules.Rule) (bool, error) {
	orig, err := m.fs.ReadFile(_pfAnchorPath) // may ENOENT
	if err != nil {
		return false, fmt.Errorf("failed to read anchor file: %w", err)
	}
	metas, err := m.walk(bytes.NewReader(orig))
	if err != nil {
		return false, fmt.Errorf("failed to parse anchor file: %w", err)
	}

	desired := make(map[string]rules.Rule, len(want))
	for _, r := range want {
		desired[r.ID] = r
	}

	var buf bytes.Buffer
	cursor := 0
	for _, bm := range metas {
		buf.Write(orig[cursor:bm.start])
		// update the block if it exists in the desired rules
		if r, ok := desired[bm.id]; ok {
			renderBlock(&buf, r)
			delete(desired, bm.id)
		}
		cursor = int(bm.end) // DELETE by skipping bytes
	}
	buf.Write(orig[cursor:])    // tail
	for _, r := range desired { // append new rules
		renderBlock(&buf, r)
	}

	if bytes.Equal(orig, buf.Bytes()) {
		return false, nil
	}
	return true, filesys.AtomicWrite(m.fs, _pfAnchorPath, buf.Bytes(), 0o644)
}

// EnsureAnchor ensures that the anchor file exists.
func (m *ManagerImpl) ensureAnchor() (bool, error) {
	m.mu.Lock()
	defer m.mu.Unlock()

	if ok, err := m.anchorOK(); err != nil || ok {
		return false, err
	}
	if err := m.writeAnchor(); err != nil {
		return false, err
	}
	return true, nil
}

// ensurePfConf guarantees exactly one copy of the anchor stanza in pf.conf.
// Returns true if the file was modified.
func (m *ManagerImpl) ensurePfConf() (bool, error) {
	data, err := m.fs.ReadFile(_pfConfPath)
	if err != nil && !errors.Is(err, fs.ErrNotExist) {
		return false, err
	}

	if hasLoader(data) {
		return false, nil // already present, including any \r\n variants
	}

	// Append with two LFs for readability; pfctl is newline-agnostic.
	patched := append(append(data, '\n', '\n'), _anchorStanza...)
	if err := filesys.AtomicWrite(m.fs, _pfConfPath, patched, 0o644); err != nil {
		return false, err
	}
	return true, nil
}

// anchorOK checks if the anchor file exists and contains the sentinel.
func (m *ManagerImpl) anchorOK() (bool, error) {
	f, err := m.fs.Open(_pfAnchorPath)
	switch {
	case errors.Is(err, fs.ErrNotExist):
		return false, nil
	case err != nil:
		return false, err
	}

	defer f.Close()
	// check if the sentinel line exists
	scan := bufio.NewScanner(f)
	for scan.Scan() {
		if strings.EqualFold(strings.TrimSpace(scan.Text()), _sentinelLine) {
			return true, nil
		}
	}
	return false, scan.Err()
}

// writeAnchor creates the anchor file with the correct header options.
func (m *ManagerImpl) writeAnchor() error {
	dir := filepath.Dir(_pfAnchorPath)
	if err := m.fs.MkdirAll(dir, 0o755); err != nil {
		return err
	}
	data := append([]byte(_anchorHeader), "\n"...)
	return filesys.AtomicWrite(m.fs, _pfAnchorPath, data, 0o644)
}

type blockMeta struct {
	id         string
	start, end int64
}

// walk reads the anchor file and returns the block metadata for each rule.
func (m *ManagerImpl) walk(r io.Reader) ([]blockMeta, error) {
	var (
		metas  []blockMeta
		curID  string
		start  int64
		offset int64
		seen   = make(map[string]struct{})
		mu     sync.Mutex
	)

	scan := bufio.NewScanner(r)
	for scan.Scan() {
		line := scan.Text()
		offset += int64(len(line) + 1) // +1 for the newline
		switch {
		case strings.HasPrefix(line, "# === VOID-RULE ") && strings.HasSuffix(line, " BEGIN ==="):
			curID = strings.Fields(line)[3]
			mu.Lock()
			if _, dup := seen[curID]; dup {
				return nil, fmt.Errorf("duplicate rule ID %s", curID) // NEW
			}
			seen[curID] = struct{}{}
			mu.Unlock()
			start = offset - int64(len(line)+1)
		case strings.HasPrefix(line, "# === VOID-RULE ") && strings.HasSuffix(line, " END ==="):
			endID := strings.Fields(line)[3]
			if endID != curID {
				return nil, fmt.Errorf("mismatched END tag for %s", curID)
			}
			metas = append(metas, blockMeta{curID, start, offset})
			curID = ""
		}
	}

	return metas, scan.Err()
}

// renderBlock appends a formatted rule block to an io.Writer
func renderBlock(w io.Writer, r rules.Rule) {
	_, _ = fmt.Fprintf(w, "# === VOID-RULE %s BEGIN ===\n", r.ID)
	_, _ = fmt.Fprintf(w, "# Domain: %s\n", r.Domain)
	if !r.Permanent {
		_, _ = fmt.Fprintf(w, "# Expires: %s\n", r.Expires.Format(time.RFC3339))
	}
	for _, ip := range r.IPs {
		_, _ = fmt.Fprintf(w, "block return out proto tcp from any to %s\n", ip.String())
		_, _ = fmt.Fprintf(w, "block return out proto udp from any to %s\n", ip.String())
	}
	_, _ = fmt.Fprintf(w, "# === VOID-RULE %s END ===\n", r.ID)
}

// parseBlock decodes one rule block that starts with
// “# === VOID-RULE <uuid> BEGIN ===” and ends with “… END ===”.
func parseBlock(b []byte) (rules.Rule, error) {
	scan := bufio.NewScanner(bytes.NewReader(b))

	var (
		r     rules.Rule
		stage int // 0 = header, 1 = IP lines
		m     sync.Mutex
		seen  = make(map[string]struct{})
	)
	scan.Split(bufio.ScanLines)
	for scan.Scan() {
		line := strings.TrimSpace(scan.Text())

		switch {
		// BEGIN line – extract UUID
		case stage == 0 && strings.HasPrefix(line, "# === VOID-RULE ") &&
			strings.HasSuffix(line, " BEGIN ==="):
			fields := strings.Fields(line)
			if len(fields) < 4 {
				return r, fmt.Errorf("malformed BEGIN line: %q", line)
			}
			r.ID = fields[3]

		// Domain header
		case stage == 0 && strings.HasPrefix(line, "# Domain:"):
			r.Domain = strings.TrimSpace(strings.TrimPrefix(line, "# Domain:"))

		// Expires header (optional)
		case stage == 0 && strings.HasPrefix(line, "# Expires:"):
			ts := strings.TrimSpace(strings.TrimPrefix(line, "# Expires:"))
			exp, err := time.Parse(time.RFC3339, ts)
			if err != nil {
				return r, fmt.Errorf("bad expiry timestamp: %v", err)
			}
			r.Expires = exp

		// First non-comment → IP lines begin
		case !strings.HasPrefix(line, "#"):
			stage = 1
			fallthrough

		// IP rule lines
		case stage == 1 && strings.HasPrefix(line, "block"):
			parts := strings.Fields(line)
			ipStr := parts[len(parts)-1]
			m.Lock()
			if _, dup := seen[ipStr]; !dup {
				seen[ipStr] = struct{}{}
				if ip := net.ParseIP(ipStr); ip != nil {
					r.IPs = append(r.IPs, net.IPAddr{IP: ip})
				}
			}
			m.Unlock()

		}
	}
	if scan.Err() != nil { // Check for actual scanner errors first
		return r, fmt.Errorf("scanner error in block: %w", scan.Err())
	}

	// If we reached the end of the block given to us without scanner errors,
	// and we successfully parsed the ID (add check if needed), consider it success.
	if r.ID == "" {
		return r, fmt.Errorf("malformed block: ID missing")
	}

	// Set permanent status *after* the loop, based on whether Expires was parsed
	if r.Expires.IsZero() {
		r.Permanent = true
	}

	return r, nil
}

// hasLoader checks if pf.conf contains the anchor loading stanza.
func hasLoader(b []byte) bool {
	const (
		l1 = `anchor "void"`
		l2 = `load anchor "void" from "/etc/pf.anchors/void"`
	)

	var l1Found bool
	scan := bufio.NewScanner(bytes.NewReader(b))
	scan.Split(bufio.ScanLines) // handles \n and \r\n
	for scan.Scan() {
		line := strings.TrimSpace(scan.Text())
		if strings.HasPrefix(line, "#") { // ignore comments
			continue
		}
		switch {
		case line == l1:
			l1Found = true
		case l1Found && line == l2:
			return true // stanza complete and contiguous
		default:
			l1Found = false // reset if lines interrupted
		}
	}
	return false
}

const (
	// anchorRules contains the required rules for the void anchor
	_anchorStanza = `anchor "void"
load anchor "void" from "/etc/pf.anchors/void"`
	_sentinelLine = "# void-anchor"
	// Header written at the very top of /etc/pf.anchors/void.
	// Header written at the very top of /etc/pf.anchors/void.
	_anchorHeader = _sentinelLine + `
# Options
set block-policy drop
set fingerprints "/etc/pf.os"
set ruleset-optimization basic
set skip on lo0

# void ruleset for blocking sites
`
)

type runner interface {
	Run(ctx context.Context, name string, arg ...string) error
}
type execRunner struct{}

func (execRunner) Run(ctx context.Context, name string, arg ...string) error {
	cmd := exec.CommandContext(ctx, name, arg...)
	return cmd.Run()
}
